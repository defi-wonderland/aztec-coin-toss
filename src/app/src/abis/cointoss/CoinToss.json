{
  "name": "CoinToss",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+3deZwcRRUH8O5ssrudzubY3PcdcmdnZ3NfSxJFQCAgCAgCgoAg933fIJfc933fIAgIAoKAICCnICAIBAREuW/Qf0zVzMv+tlI2U/IeM8O++nz2k+munnrfquru6Zqu6aRRFMVRIdUs/+scrZwov7X4b9PXS7mYr6wmSWenKnHWMDpjzz7A7e0s0K7cxi5VYKytAmMd875JRtpH65f/Jcv/ui7/S5f/bVpfWJ9EK+/HZl0Xp55mXW3xdSdYV1d8XVP8t7YYi7v/It4yW2r5+7ApgbbpDG1EbdMlWrnNaz1tXudp83ooowfkR06fdC++pztzH5hYDVH7FDvLrfC6O9SvB6+lKQVLD4jTS6DOPaPS60zxU3gf+noL+BoDfL3B1+jx9RXw9Qnw9QVfH4+vv4CvX4CvP1gG8FrsPk2WARBnkECdB0al15nip/A+9A0R8A0O8A0B32CPb5iAb2iAbxj46H24T48Q8A0P8I0A33CPb5SAb2SAbxT4Rnp8YwR8owN8Y8A32uMbJ+AbG+AbB76xHt94Ad8qAb7x4FvF45so4JsQ4JsIvgke32QB36QA32TwTfL4pgr4pgT4poJvisfXJOCbFuBrAt80j69ZwJcL8DWDL+fxtQj48gG+FvDlPb4ZvL5m45se4JsBltm8lhZjmRlgmQ2WWbwWO0aew1umPTTmgp/qSnFSyMc+n8tctxhiUrm0jD61dmyrsUx3nAlsN70CfLRulqAlcSwmZZ2XfD7sy/m8PnsOnxfgmw+WVlZL3n5ntyDA0gqWhayWwjl8Vd4y7Tl8EfiprhQnhXzs80XMdYshJpVLy+hTq1rVqla1qlWtalWrWtWqVrWqVa1qVata1apWtapVrWpVq1rVqla1qlWt/FZjmec4E9huXgX4aN1CQUviWEyKneVWeO3zYV8u4fXZOTWLA3xLwLIaq6XZzqn5ToBlNbB8l9VSmFPzPd4y7Zya1cFPdaU4KeRjn6/OXLcYYlK5tIw+tapVrWpVq1rVqla1qlWtalWrWtWqVrWqVa1qrRarsSx2nAlst7gCfLTuu4KWxLGYlPU9u8+Hfbkmr8/ek1gjwLcmWNbmtdhnNXw/wLI2WNbitdh7EuvwlmnvSSwFP9WV4qSQj32+lLluMcSkcmkZfWrt2FZjWcNxJrDdGhXgo3VrCVoSx2JS1nnJ58O+XI/XZ8/h6wb41gPLBqyWnL2v/IMAywZgWZ/VUjiH/5C3THsO3xD8VFeKk0I+9vmGzHWLISaVS8voU6ta1apWtapVrWpVa8e2Gsu6jjOB7datAB+tW1/QkjgWk7LGKT4f9uXGvD47ptsowLcxWDZltRTGdD8KsGwKlk1YLYUx3Y95y7Rjus3AT3WlOCnkY59vxly3GGJSubSMPrWqVa1qVata1apWtXZsq7Fs5DgT2G6jCvDRuk0ELYljMSlrnOLzYV9uweuzY7rNA3xbgGUrActPAixbgWVLXosd0/2Ut0w7ptsa/FRXipNCPvb51sx1iyEmlUvL6KsWq7Fs7jgT2G7zCvDRui0FLYljMSnr+PH5sC+35fXZ43ubAN+2YNlewPKzAMv2YNmO12LPNT/nLdOea3YAP9WV4qSQj32+A3PdYohJ5dIy+qrFaizbOM4EttumAny0bjtBS+JYTMo6fnw+7MudBHw7Bvh2At+OHt8uAr6dA3y7gG9nj283Ad+uAb7dwLerx7eHgG/3AN8e4Nvd49tLwLdngG8v8O3p8e0j4Ns7wLcP+Pb2+PYT8O0b4NsPfPt6fAcI+PYP8B0Avv09voMEfAcG+A4C34Ee3yECvoMDfIeA72CP7zAB36EBvsPAd6jHd4SA7/AA3xHgO9zjO0rAd2SA7yjwHenxHS3g+0WA72jw0fvw/ws/VsB3TIDvWPAd4/EdL+A7LsB3PPiO8/hOEPD9MsB3Avjofbj/nSTgOzHAdxL4TvT4ThHwnRzgOwV8J3t8pwn4Tg3wnQa+Uz2+MwR8pwf4zgDf6R7fWQK+MwN8Z4HvTI/vHAHf2QG+c8B3tsd3noDv3ADfeeA71+O7QMB3foDvAvCd7/FdJOC7MMB3Efgu9PguEfBdHOC7BHwXe3yXCfguDfBdBr5LPb4rBHyXB/iuAN/lHt9VAr4rA3xXge9Kj+8aAd/VAb5rwHe1x3edgO/aAN914LvW47uB12e/378+wHcDWG7itdjfkP8qwHITWG7ktdh7Db/mLdPea7gZ/FRXipNCPvb5zcx1iyEmlUvL6FNrx7Yay/WOM4Htrq8AH627UdCSOBaTss5LPh/25a28PnsOvyXAdytYbme1FJ5N/psAy+1guY3VUjiH/5a3THsOvwP8VFeKk0I+9vkdzHWLISaVS8voU6ta1apWtapVrWpVq1rVqla1qlWtalWrWtWq1mqxGsstjjOB7W6pAB+tu03QkjgWk7K+Z/f5sC/v4vXZexJ3BvjuAss9rJbCPYnfBVjuAcvdrJbCPYnf85Zp70ncC36qK8VJIR/7/F7musUQk8qlZfSpVa1qVata1apWtapVrWpVq1rVqla1qlWtalVrtViN5U7HmcB2d1aAj9bdLWhJHItJsbPcCq99PuzL+3l99p7EfQG++8HyIKul8P8y/CHA8iBYHmC1FO5J/JG3THtP4iHwU10pTgr52OcPMdcthphULi2jT61qVata1apWtapVrR3baiz3Oc4EtruvAny07gFBS+JYTMoap/h82JeP8PrsmO7hAN8jYHmM1VIY0/0pwPIYWB5ltRTGdI/zlmnHdE+An+pKcVLIxz5/grluMcSkcmkZfWpVq1rVqla1qlWtau3YVmN52HEmsN3DFeCjdY8KWhLHYlLWOMXnw758itdnx3RPBvieAsszrJbCmO7PAZZnwPI0q6UwpvsLb5l2TPcs+KmuFCeFfOzzZ5nrFkNMKpeW0adWtapVrWpVq1rVqtaObTWWJx1nAts9WQE+Wve0oCVxLCZljVN8PuzL53l9dkz3XIDvebC8yGux/8/AXwMsL4LlBV6LHdP9jbdMO6Z7CfxUV4qTQj72+UvMdYshJpVLy+hTa8e2GstzjjOB7Z6rAB+te0HQkjgWk7LOSz4f9uUrvD57Dn85wPcKWF7jtdhz+LIAy2tgeZXXYs/hf+ct057DXwf/suK/FCeFfOzz15nrFkNMKpeW0afWjm01lpcdZwLbvVwBPlr3qqAlcSwmZZ2XfD7syzd5ffYc/kaA702w/FPA8o8AC8U3lrec/Kavl+w5/F+8Zdpz+Nvgp7pSnBTysc/fZq5bDDGpXFpGX7VYjeUNx5nAdm9UgI/WvSVoSRyLSVnHj8+HffmugO+dAN+74HvH43tfwPdegO998L3n8X0o4PsgwPch+D7w+D4W8H0U4PsYfB95fJ8K+D4J8H0Kvk88vs8FfJ8F+D4H32ce35cCvi8CfF+C7wuP7z+8vmZTxr+LZXUu/kUQpwby36lt2662ts3UwNxmcbFcbB9abojKH7c7b1x7DdcQtU9Z+0h3sPTitdjvBHoEWHqBpSevxV5PNvKW2WTK7M1cpimjD7QJtR/ZU8jvDe3Vh7m9YohJ5dIy+tTasa3G0uA4E9iuoQJ8tK4n+Oqc9jOfQxPhc6gHr7XFWPFcezAYKFYNbHM/fD5OLb7uCvkNUJee0cptzXwut21NcahcWqZYXaEuPcHCfS6Po/afK60VFpe57e1nAu7n3T3tTvEbwcH82ZQzZfTxOHqDwz3+jKMvr8NeZ/bzOPqCg+L3A0d/XkfelDHA4+gPDoo/ABwDeR12XIAOk7KuswaCZbCAZVCAZTBYhgpYhgRYhoJluIBlWIBlOFhGClhGBFhGgmW0gGVUgGU0WMYKWMYEWMaCZRUBy7gAC8U31zt0LugJ6+iYxGtIOjbwWon20X6wbkTxdSdYR31WA+uo7Wjcb9plvGNt+prJxKF2GQ9xJvHGsWPXCVH7lNX+k8Aykddix66Tecu01xRTwE91pTgp5OO1zRTmusUQk8qlZfSVam2sImufKrL2K7NV4hgwZU7lLbOl2/Iy6qEtpzptivXJ8ca23/1Ni9qnrHNWDixNvBZ7zmrmLdMS8+CnulKcFPLxMyjPXLcYYlK5tIy+Uq1TymwViNtMx8E0J9Zkpx1M7BnMsc1x0BK1T1nHwQywTOe12ONgJm+Z9jiYBX6qK8VJIb8T1G0Wc91iiEnl0jL6SrU2l9kq0FctpszZvGWuOLaoLWc7bYr1mccc2xxbc6L2KevYmgeWubwWe2zN5y3THlsLwE91pTgp5NdA3RYw1y2GmFQuLaOvVOusMlsF+ipvylzIW+aKY4vacqHTplifRbyx7ZiTyqKUdWwtAsuqvBZ7bC3mLdMeW0s8daE4KeTjZ8ES5rrFEJPKpWX0lWqdVUXWBVVk7VVma1L0YFyzrlvxNR1z9h5dfeF1Nd6jw3yTuhT/rYP3uOUI3F9qkbhHbMqg+0Kdoe4Upwbyn4B7rk8VXydQ5+5QzjJPPqWsczber2e+H9Vk4uJ9plaIgXG57z9h3Lj4RzFofQ28fqW2rT0Gtr3MvH+G2+HrXs57UsjvJ1zn/uBohWWKZfaTZ2CfWgbzC5jnIuWwvtguddAulI/f50oebxjfN1+EjOYYov0Tz4/9mG0xxKFyaRnvd9C6RvBRPfBcMlHnLbKOKytk3mJe5y2GJ1OGzq/r2NZqnQtY77SfObd3q2uzMs8FzPvmAtY77YZzAfP1ba6eRZfOBWyz6FxAnQvoOr7huYB27IWOGOL2h7gDmPshidqPQyg2plZ4jePDQQKWgQGWQWAZImAZHGAZApZhApahAZZhYBkhYBkeYBkBllEClpEBllFgGSNgGR1gofjmmoKOP5xvR8cBXqfR/ohjTdovOsE66h+cW0fthPMamOc/2rl11AZUNs5DxPPnBN7YdsxFcxgpZbX/BLAwzzHMCczhs5/bk8BPdaU4KeTj9QPzvEZ73TIxat+mtIy+Uq2NVWQdV2arxH4lMC8uT/dAqS0nO22K9ZnGG9t+D4RzEk3KOg9MAwvzXL6cwLw4W1wO/FRXipNCPp7rmecK2v21KWrfprSMvlKtk8pslZhPScfBFCfWRKcdTOwW5tjmOMB5eyZlHQctYOGeQygwL8423QzwU10pTgr5OIeNea6g3bemR+3blJbRV6q1qcxWgb5qEZgXt+LYorac6bQp1mcOc2xzbOGcRJOyjq05YGGey5cTmBdnd8F54Ke6UpwU8nEOG/NcQbu/zo3atykto69U64wyWwX6Ki8wL27FsUVtOd9pU2xvmg9krjVoX6DvEmsg//G6tu2OLr5OoEwcGzLP3c2HzjnF+VgSx6vEfG48r1NdcY405ePYkHuuetYcafSVam2sIuvcMlsl9iuB69K8Oz/Wnc+P9ZH4fRP+psakUn/fxPxbpJzA2NeeB6aCn+pKcVLIx7Eh97g3jtr/jqwVltFXqnV6ma0CcVd8xuadWDOddhD4rin4OxIcmzN/VyT2XSn+9prqit/pUT6ODZm/k878Tg99pVqnldkq0FctAt+/r/S9y3inTbE+zPdAmkPvQ+AzIMbxWnIC97nssYX3uaiueD+L8nFsyP3cjzhq/6yNVlhGX6nWCWW2CvRVXuCea7P73f4op02pPknxD9fZZ3rWt+Xr2E/Hfv/LqmO/0q069vvKpGO/SMd+/49Vx35tFh37lV43Hft9ZSrr2A+vT2mde33aFbal/Nr6tvbgfi4HXhNTyjo2Kb7APc6cwLW4PTbxWobqSnFSyO8KdWO+trH7+yynTWkZfaVaG8tslegrgWvZFccmteV0p02xPszXXC2hz3TC50dIzIdhvr61xxZey1BdKU4K+TjHhPk61O6vOadNaRl9pVpnVJF1XhVZZ5bZis/GaIF19GwMfA7fVPhMboC60Dr6zU43WEfXdvjbNvo+krY30xC+Tc/bqIf3fAPP28hL/A7TlFHq8zYWwu8aV4V9xPe8jaWefEr6vI3s522sQztW9O1/3sYS2KeWwrX+N/W8jXpol3I8b4PiV/vzNqgeeC6h32S7xzsbmB7yYQKYD6CaYuAuxQaqg5j0JVx91DbYTCH/vyl4qnJBdQEA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "divinity",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "private_oracle",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "house",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "bet_amount",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "H4sIAAAAAAAA/+XdZ3MTVxQG4JWtgpNAICRxo9j0YmBXWlmrkOJAeiGkF1KwYikhBRPiFEIKIZXee++99/rTGM47cwWLEPBBxwyXd2fOrOtqn7vS1nvPuew4zl7n+hQx8zYzdyubvJgsI1ZmuSm31ffzmWTeS3ntbjKbC9Kun861Bl7gpYN0RzJIpfKBH2SyuWzGzXp+Ku8V0tlUwSw4preObne447KMeDe44/e4OyHLSHSDO6HsvtX7vdL1bFRcz4hpyyazvFqJKxJ1Zl5v5g1m3nifz1sk+plthnbpbdql3z2wXv2dGyft99UAR+8zWmy/4joOMA7sWwaG2jdqfn+n9x2mptD/VZUstyn0d80S1SZuNbUpOqPO7beLW9nk1Tr6+yXtdayzYB3rLVjHBufuHIPcyiav2dE9BhWnQRJ9zdc1zs2fYfwsWmLCPiWm7Ksxy8VUFXodR/d1/HLnb26FU01onavLtGW0TFvGQj+LlXjxfc/Q752Sdull/jauvA1K961toe+Lr9VDoo/5enpn17TCrIkz8+1d+Y5JnV358BsrXtIgYUCkTOMU4UV0omQ54UZOhObh17y21hqtEV6m9qd5kGPHme9gnfUs+En/hvWsUm7PiKJ5SDdtG21zlaJ5qCXmakXzMEvMUUXzcEvMMUXzCEvMcUXzSEvMCUXzKEvM/RXNoy0xNyqaWwjNYwjNYwnN4wjNLqHZIzQnCc0pQrNPaE4TmlsJzRlCc0BozhKanyA0jyc0P0loforQ/DSh+RlCcxuh+VlC8wRC80RC83OE5ucJzS8Qml8kNL9EaH6Z0PwKoflVQvNrhObXCc2TCM1vEJonE5rfJDS/RWh+m9D8DqH5XULze4Tm9wnNHxCaPyQ0f0RonkJo/pjQ/Amh+VNC82eE5qmE5nZCc47Q/DmhuYPQnCc0FwjNXxCavyQ0TyM0f0Vo/prQ/A2h+VtC83RCc6cl5mZF8wzC7fwdoXkmofl7QnMXofkHQvOPhOafCM0/E5pnEZp/ITTPJjT/Smj+jdD8O6H5D0vMAxXNcwi385+E5rmE5r8IzX8Tmv8hNP9LaP6P0Pw/oXkeoXk+oXkBoXkhoXkRoXkxoXmJJebBiualhNt5GaF5OaF5BaF5JaF5FaF5NaF5DaF5LaF5HaF5PaF5A6F5I6F5E6F5M6F5C6F5K6F5G6F5O6F5B6F5J6F5F6F5N6F5D6F5L6F5H6F5P6H5AKH5IKH5EKH5MKH5iCXmHormo5aYaxTNxywxP6BoPm6J+UFF8wlLzA8pmk9aYu6paD5libmXovm0JeaHFc1nLDH3VjSftcTcR9F8zhLzI4rm85aY+yqaL1hiflTRfNES82OK5kuWmB9XNF9WNDeY5USMuVoiKhGTiEskJHBNiGskXDPgHBrnlDjHwjkHjsE4JmEfjX0WPsN4T2Mbw1wrUSdRL9EQat8NZj5EYqjEMInhEiMkRkqMkhgt0SIxRmKsxDh4JTyJJNpRwpdIS7RKZCQCiawEat6Pl0BNdNQIR83sYg1p1BieIIEatKjJihqlqNmJGpao6Ygah6j5hxp4qAmHGmmoGYYaWpMlUGMJNYdQgwc1aVCjBTVLUMMDNS1Q4wE1D6ZIICc+csQjZzpyiE+VQI7pnARyECMnL3LUImcrcpgipydyXCLnI3IgIicgcuQhZxxyqM2QQI4t5JxCDibkJEKOHuSsQQ4X5DRBjg/kvJgtgZwIyBGAMfMYQz5HAmOM50pgDCrGZGKMIsbsYQwbxnRhjBPG/GAMDMaEYIwExgygD/1SCfSxRp9j9MFFn1T00USfRfThQ5829PFab7Yx+sSgjwj6TKAPwVYJPGPeLoFnkHgmh2dUeGaDZxi4p4973Ljni3uguCeIe2S4Z4R7KLingGtsXHPiGgzXJDhHxzkrzuFwToNjPI55OAZgn4h9BD4zxekqP+Y04UalAAA=",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "create_bet",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "bet",
          "type": {
            "kind": "boolean"
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_config_unconstrained",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [],
      "returnTypes": [
        {
          "kind": "struct",
          "path": "types::config_note::ConfigNote",
          "fields": [
            {
              "name": "divinity",
              "type": {
                "kind": "struct",
                "path": "aztec::types::address::AztecAddress",
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "private_oracle",
              "type": {
                "kind": "struct",
                "path": "aztec::types::address::AztecAddress",
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "house",
              "type": {
                "kind": "struct",
                "path": "aztec::types::address::AztecAddress",
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "kind": "field"
                    }
                  }
                ]
              }
            },
            {
              "name": "bet_amount",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "header",
              "type": {
                "kind": "struct",
                "path": "aztec::note::note_header::NoteHeader",
                "fields": [
                  {
                    "name": "contract_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "storage_slot",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_transient",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              }
            }
          ]
        }
      ],
      "bytecode": "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z2eTffVb8lXGMf83TFgl8+IV6FyD9kKwuX7txWBz7dulYHPd3EvB5pq7y8Hmer0rwT4H7WqwL0DTteA5aBqXvwBNz0hehKbn1ZegheTf4ORav8vQtF7rCjSNwcWp79Rrrqse/tfubkvLlOtY69jn+2RF+O3N+O3N+L3dd7GKYCllWEoNWPoNsfQYYuk1xFIxxNJhiKVsiGWhIZZuQyxVQyydhljaDLH0GWJZYIilyxBLuyGWlnvMcrv3gxTeDW0gw59og8FeAE3PQ3ugaW6qF5rWCSyE1prDp2vTADS1+UFoKtfF0HSNHYKmvkv+k/Mme+bC9Qy1FedoPovvo2htQRu0CcQpje9qS5sMdic0PS/tgrYCtv5rHQHLRmkZhaY0j0FT3oxDUx5OQFNeL4OmMpmEpnVty6FpXS/Z9V7Dypx0sA3onHr4X7u7LW0D9FPHvnzxPZ2VBljaDbF0GWJZYIilzxBLmyGWTkMsVUMs3YZYFhpiKRti6TDEUjHE0muIpccQS78hltZ5YtH4UfEuzrAU5Xcg43dgnvwOZ/wOz5PfkYzfkXny6+U7P369fOfHr+XynYzqd9slPi/Q1ugZ0CRYlkdlmf09nGVx40x/W3oicpxJHOPIE+Wf2KsI5/dFxyPnVwt8Kl7tjxfnN03/2AekfyyHY2we008+Z3VWZ3XWO2WdcNZCWL2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC5zV66uzOquz+rXAWb2+OquzOqtfC+6cNfE7GtXvlZlKxm+yNXqnfLTAPEjiXBU3zvT959XgV1rlp4pw1sXVkdPWAp+KV/vkc1ZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZndVZnvV9YqwhvBcuqAlhKGZZSTr5oW2KIZZEhlmFD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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "get_user_bets_unconstrained",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "user",
          "type": {
            "kind": "struct",
            "path": "aztec::types::address::AztecAddress",
            "fields": [
              {
                "name": "address",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "private"
        },
        {
          "name": "start_offset",
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 10,
          "type": {
            "kind": "struct",
            "path": "std::option::Option",
            "fields": [
              {
                "name": "_is_some",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "_value",
                "type": {
                  "kind": "struct",
                  "path": "types::bet_note::BetNote",
                  "fields": [
                    {
                      "name": "owner",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::types::address::AztecAddress",
                        "fields": [
                          {
                            "name": "address",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "randomness",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "bet",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "header",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::note::note_header::NoteHeader",
                        "fields": [
                          {
                            "name": "contract_address",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "nonce",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "storage_slot",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "is_transient",
                            "type": {
                              "kind": "boolean"
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        }
      ],
      "bytecode": "H4sIAAAAAAAA/+2dCZgcxXn3Z3b2mp29L+2t2ZW00koraXZX5+oa3fd9oQt03weHOM0VgjEhBGNCCMEYE0KcYPhshxwOJHbw5xD8JQ75EiCHg+PYmGBCgNzO4eB09dar/W+pNFaHqtWr6O3nqWeq/9Vd76/Oruqu7tkQi8XisYEtEbi82NkbhWf1b+bDbT1xd3FlfHLmOeSMA+M6yO/8wBUErjBwRYErDlwycCWBSwWuNHBlgSsPXEXgKgNXFbjqwNUErjZwdYGrD9yIwDUErjFwTYFrDlxL4FoD1xa4kYFLB649cB2BGxW40YEbE7jOwI0N3LjAdQVufOAmBK47cBMDNylwk1U+BK4ncL2B6wvclMBNDdy0wE0P3IzAzQxcf+BmBW524OYEbm7g5un8nB+4BYFbGLhFgVscuCWBWxq4ZYFbHrgVgVsZuFWBWx24NYFbq/NufeA2qLjrB/JR5ZdZb5M6fynPYzqPacvq38yH3ApjzutdBtOTZ0kP/RZoPQa/eE65TnOBW74eZSs/NnSLG/tZ8BdA/he6ZcmkgKUQfos9pLkodv5pJvspOA/5SjzwJSPwlQBf0sJX6oEvFYGvFPhSFr5yD3xlEfjKgaXCLUtYp4mlAuxUeUhzZez800z2U3Ae8tV44KuOwFcDfNUWvjoPfLUR+OqArxa46HeEB776CHwjgK/ewtfoga8hAl8j8DVY+Jo98DVF4GsGviYLX6sHvpYIfK3A12LhG+mBry0C30jga7PwtXvgS0fgawe+tIVvlAe+jgh8o4Cvw8I3xgPf6Ah8Y4BvtIVvrAe+zgh8Y4Gv08LX5YFvXAS+LuAbZ+Gb4IFvfAS+CcA33sI30S1fr+LrjsA3EVgyblmmKJZJEVgywDLZLUuPirPHbZwhbi/wU1rJTgrCscx7HactDjYpXtpHPmG9tFkVS7fBmYTjuhnwkTbZI0vSYFFbrn7JxodlOcUtX9iH90XgmwIs052y9IX33aZGYJkOLNOcsgz04TPcxhn24TOBn9JKdlIQjmU+03Ha4mCT4qV95BNWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVWYRVW96yKpc/gTMJxfQz4SJvmkSVpsKgt1zoRGx+W5Sy3fOGamv4IfLOAZa5Tlt5wTc3sCCxzgWWOU5aBNTXz3MaZMfkprWQnBeFY5lnHaYuDTYrXTKuwCquwCquwCquwCquwCquwCquwCquwCquwCquwCuvFxKpY+g3OJBzXz4CPtDkeWZIGi9py3We38WFZLnDLFz6TmB+BbwGwLHbLEn6rYWEElsXAssgtS/hMYonbOMNnEkuBn9JKdlIQjmW+1HHa4mCT4qV95BPWS5tVscw3OJNw3HwGfKQt8siSNFjUlqtfsvFhWS53yxf24csi8C0HllVOWXrC58orIrCsApaVTlkG+vDVbuMM+/A1wE9pJTspCMcyX+M4bXGwSfHSPvIJq7AKq7AKq7AKq7AK66XNqliWGZxJOG4ZAz7SVnpkSRosass1T7HxYVmuc8sXzunWRuBbBywbnbIMzOnWR2DZCCwbnLIMzOk2uY0znNNtBn5KK9lJQTiW+WbHaYuDTYqX9pFPWIVVWIVVWIVVWIVVWC9tVsWy1uBMwnFrGfCRtsEjS9JgUVuueYqND8tyq1u+cE63JQLfVmDZ7oHlsggs24Flm1uWcE63w22c4ZxuJ/BTWslOCsKxzHc6TlscbFK8tI98FwurYtlicCbhuC0M+Ejb5pElabCoLVf7sfFhWV7uli9s37si8F0OLHs8sFwRgWUPsOx2yxL2NXvdxhn2NfuAn9JKdlIQjmW+z3Ha4mCT4qV95LtYWBXLLoMzCcftYsBH2m6PLEmDRW252o+ND8vygAe+/RH4DgDffgvfIQ98ByPwHQK+gxa+Ix74DkfgOwJ8hy18xzzwHY3Adwz4jlr4TnjgOx6B7wTwHbfwnfLAdzIC3yngO2nhu8oD35UR+K4CvistfNd44Ls6At81wHe1he9aD3ynI/BdC3ynLXzXe+C7LgLf9cB3nYXvRg98N0TguxH4brDwfcQD300R+D4CfDdZ+G7xwHdzBL5bgO9mC99tHvhujcB3G/DRefh/4T/mge/2CHw/Bny3W/h+3APfHRH4fhz47rDwfdQD350R+D4KfHcCF/1+zAPfXRH4PgZ8d1n4fsID390R+H4C+O628P2kB757IvD9JPDdY+H7KQ9890bg+yngu9fC93EPfPdF4Ps48N1n4fuEB777I/B9Avjut/D9tAe+ByLw/TTwPWDh+xkPfA9G4PsZ4HvQwvezHvgeisD3s8D3kIXv5zzwPRyB7+eA72EL3yc98D0Sge+TwPeIhe9THvgejcD3KeB71ML3aQ98j0Xg+zTwPWbh+3kPfI9H4Pt54HvcwvcLHvieiMD3C8D3hIXvF93yhff3n4zA94vA8stuWcJ3yD8TgeWXgeWX3LKEzxqechtn+Kzhs8BPaSU7KQjHMv+s47TFwSbFS/vIJ6yXNqtiedLgTMJxTzLgI+2XPLIkDRa15eqXbHxYls+45Qv78Kcj8D0DLJ93yjLwbfL/E4Hl88DyOacsA334F9zGGfbhvwL8lFayk4JwLPNfcZy2ONikeGkf+YRVWIVVWIVVWIVVWIVVWIVVWIVVWIVVWIVVWIVVWC8WVsXytMGZhOOeZsBH2uc8siQNFrXlus9u48Oy/FW3fOEziWcj8P0qsPyGU5aBZxK/FoHlN4Dl152yDDyT+KLbODMqjt8Efkor2UlBOJb5bzpOWxxsUry0j3zCKqzCKqzCKqzCKqzCKqzCKqzCKqzCKqzCKqzCKqwXC6tiedbgTMJxzzLgI+3XPbIkDRa15brPbuPDsnzeLV/4TOK5CHzPA8uXnLIM/C/Db0Vg+RKw/LZTloFnEl92G2f4TOJ3gJ/SSnZSEI5l/juO0xYHmxQv7SOfsAqrsAqrsAqrsAqrsF7arIrlOYMzCcc9x4CPtN/2yJI0WNSWa55i48Oy/IpbvnBO90IEvq8Ay+86ZRmY0/3fCCy/CyxfdcoyMKd70W2c4Zzu94Cf0kp2UhCOZf57jtMWB5sUL+0jn7AKq7AKq7AKq7AKq7Be2qyK5QWDMwnHvcCAj7SvemRJGixqyzVPsfFhWX7NLV84p3spAt/XgOUPnLIMzOn+XwSWPwCW33fKMjCn+7rbOMM53R8CP6WV7KQgHMv8Dx2nLQ42KV7aRz5hFVZhFVZhFVZhFVZhvbRZFctLBmcSjnuJAR9pv++RJWmwqC3XPMXGh2X5R275wjndyxH4/ghY/sQtS/g/A/8/AsufAMsfu2UJ53SvuI0znNO9CvyUVrKTgnAs81cdpy0ONile2kc+Yb20WRXLywZnEo57mQEfaX/skSVpsKgtV79k48Oy/FO3fGEf/loEvj8Flr9wyxL24X8WgeUvgOXP3bKEffg33MYZ9uF/CfyUVrKTgnAs8790nLY42KR4aR/5hPXSZlUsrxmcSTjuNQZ8pP25R5akwaK2XP2SjQ/L8ptu+cI+/PUIfN8Elr/2wPJXEVj+Gli+5ZYl7MO/7TbOsA//DvBTWslOCsKxzL/jOG1xsEnx0j7yXSysiuV1gzMJx73OgI+0b3lkSRosasvVfmx8WJbf9cD3RgS+7wLfGxa+v/HA92YEvr8BvjctfN/zwPdWBL7vAd9bFr6/9cD3dgS+vwW+ty18f+eB750IfH8HfO9Y+N7zwPduBL73gO9dC9/fe+B7PwLf3wPf+xa+f3DL16vi/EencfZOU3H+k9s4p6s4/9ltnDNUnP/iNs6ZKs5/dRvnHhXn993GuVfF+W9u49yn4vxPt/Vzpmo//x4buuVqP2RfsfyHW5ZwfPsDt3FmVJz/5ZhTxfEB5AnlH7GnIPy/IL8+cMwRB5sUL+1/4M9uOGf44Y9I/w8tHD8cxvQj3/my5l1ErBUXEevFVAcKLyJWqQN+WC90HfBwHQyvrfG40zjDsQPmqdpyjR3IfiEc6DJ9eW7jDK9zCUjQmeuE1lIQjm0x4ThtcbBJ8dI+8p0v6wcXmNWD3bCs8n9E+vMtHPnDmH7kO19WrFfcWT+4iFilDvhhlTpw/qwerll7UoMmh8xnfKQPt2zs7PxHlvmMWN5kxNLNiOUVRixpRixfZsRSy4jlKUYsRYxYHmHEch8jljsYsVzHiOUoI5YdjFgSjFiWMGJ5ixFLDyOW1xixdDBieYERSz0jlqcZsSQZsTzKiOV+Rix3MmK5gRHLcUYsuxixLGPE8jYjlj5GLN9gxDKaEcuLjFgaGLF8gRFLihHLY4xYHmDEchcjlpsYsZxkxLKXEctqRizvMGKZwYjldUYsnYxYXmLE0sSI5VlGLGWMWB5nxPIgI5a7GbHczIjlSkYs+xmxrGXE8i4jln5GLN9mxDKOEcvXGbG0MGL5IiOWSkYsTzBieYgRyz2MWG5lxHI1I5aDjFg2MWJ5nxHLPEYsbzBiGc+I5WVGLG2MWJ5jxFLNiOVJRiz5jFgeZsRyLyOW2xmxnGbEcpgRyxZGLPELzJKMnf3ebRLCK0Ar0Np1oBVq7QbQirR2E2jFWrsZtKTWbgWtRGu3g5bS2h2glWrtTtDKtHYXaOVauxu0Cq3dA1ql1u4FrUpr94FWrbX7QavR2gOg1WrtQdDqtPYQaPVaexi0EVp7BLQGrT0KWqPWHgOtSWuPg9astSdAa9Hak6C1au0p0Nq09jRoI7X2BdDSWnsWtHatfRG0Dq09B9oorX0ZtNFaewG0MVp7EbROrb0E2litfR20cVp7GbQurb0C2nitvQbaBK19A7Rurb0O2kStfRu0SVp7A7TJWnsTtIzW3gKNGvDboPVq7R3Q+rT2LmhTtPY+aFMtbXqa1vJBm661ItBmQH9BvzON/kxp/VorA22W1ipBm621atDmaK0WtLlaqwdtntYaQMtqrQm0+VprAW2B1tpAW6i1NGiLtNYB2mKtjQZtidY6QVuqtXGgLdPaeNCWa60btBVa6wFtpdb6QFultRmgrdZaP2hrtDYPtLVamw/aOq0tAW291paBtkFrq0HbqLW1oG3S2ibQNmttC2hbtLYDtK1a2wXaZVrbC9o2re0HbbvWDoK2Q2uHQduptaOg7dLacdAu19pJ0K7Q2pWg7dba1aDt0dpp0PZq7R9A26e1fwRtv9b+CbQDWvtn0A5q7V9AO6S1fwXtsNa+D9oRrf0baEe19u+gHdPaf4B2XGs/AO2E1n4I2kkaXED/cUr7C+G4K7WWB8ddpf0JOC5P+3H8QuEFoJ2ZK4FWoLUi0IihGLQz/R5oxVorAY36whRoJVorBY36xzLQSrVWDhr1mRWglWutEjTqv6tAo761GrQqrdWARv1tLWg1WqsDjfrgetDqtDYCNOqXG0AbobVG0KivbgKtUWvNoFH/3QJas9ZaQaM+vQ20Vq2NBI36+TRoI7XWDlpaax2gtWttFGh0PRgN2iitjQGNrhGdoI3R2ljQ6LoxDrSxWusCja4l40Hr0toE0Oj60g3aBK1NBI2uOZNAm6i1yaBN0loGtMla6wEto7Ve0Oga1gdar9amgEbXtamgTdHaNNCmam06aNO0huOT6VqbCRpdJ/tBm6m1WaDRtXM2aLO0Nge02VqbC9ocrc0Dba7WsqDRtXg+aFmtLQBtvtYWgrZAa4tAW6i1xaAt0toS0BZrbSlodL1fBtpSrS0HjcYAK0BbrrWVoK3Q2irQVmptNWirtLYGNBpTrAVtjdbWgUbjjPWgrdPaBtDWa20jaBu0tgm0jVrbDBqNW7aAtllrW0GjscxloG3V2jbQLtPadtC2aW0HaNu1thM0GhvtAm2n1i4HjcZLV4B2udZ2g3aF1vaAtltre0Hbo7V9oNH4az9o+7R2ADQakx0E7YDWDoFG47TDoB3S2hHQaOx2FLQjWjsGGo3njoN2TGsnQKMx3knQTmjtFGg07rsSxy9ao/GJGlfckoRwGsvEIB7LWIbOR3tkB7nIr3/CMQudk9Va5sNtYVeOdrKwT7ZKgIHCLiTLFkYshxmxnGbEcjsjlnsZsTzMiCWfEcuTjFiqGbE8x4iljRHLy4xYxjNieYMRyzxGLO8zYtnEiOUgI5arGbHcyojlHkYsDzFieYIRSyUjli8yYmlhxPJ1RizjGLF8mxFLPyOWdxmxrGXEsp8Ry5WMWG5mxHI3I5YHGbE8zoiljBHLs4xYmhixvMSIpZMRy+uMWGYwYnmHEctqRix7GbGcZMRyEyOWuxixPMCI5TFGLClGLF9gxNLAiOVFRiyjGbF8gxFLHyOWtxmxLGPEsosRy3FGLDcwYrmTEcv9jFgeZcSSZMTyNCOWekYsLzBi6WDE8hojlh5GLG8xYlnCiCXBiGUHI5ajjFiuY8RyByOW+xixPMKIpYgRy1OMWGoZsXyZEUuaEcsrjFi6GbG8yYhlPiOWPIMF3yu6CjR6pwnfT6JzT4FG4yE6vkinj9ZNZB2mj97LonhpH7/B7MPuccPuccPuuf7f2gdLzGCJ5WCZx4hlJiOWPkYsExmxHGPEcpwRy1hGLPsZsbQzYrmcEUszI5bLGLHUMWLZwIilghHLKkYsSUYsSxixJBixZBmx9DNimcKIZRIjlhOMWMYxYjnAiKWDEcsVjFhaGLFsY8RSz4hlIyOWSkYsqxmxlDBiWcqIJZ8Ry3xGLLMYsUxlxDKZEctJRixdjFgOMmIZxYhlNyOWVkYs2xmxjGDEsokRSxUjljWMWFKMWJYxYilgxLKAEctsRizTGLFkGLGcYsQynhHLIUYsoxmx7GHE0saIZQcjlgZGLJsZsVQzYlnLiKWUEctyRiyFjFgWMmKZw4hlOiOWHkYsExixHGbEcoQRyxhGLHsZsYxkxLKTEUsjI5YtjFhqGLGsY8RSxohlBSOWIkYsixixzGXEMoMRSy8jlm5GLEcZsXQyYtnHiCXNiGUXI5YmRixbGbHUMmJZz4ilnBHLSkYsxYxYFjNiiV9gliQwxECj8N2gXaX9e0Cj/9LZC9o12r8PNPrPQPwv9Wu1/wBo9M2Wg6Bdr/2HQKNv0+F/rt+o/UdAo+/e4v+wf0T7j4FG39TH/2a/RftPgHbm/3pAu037T4GWp/2Yz/S+zlWg0VpP/F93WidwDWh0jxn/653mJ9eCRu3sOtDo/anrQaO1tzeARvXyRtDonv9NoNF88SOgUb93M2j0PtstoFVq/62g0ToaykeV/qWlg+F0fh6cQ3bw/05vs9i71cJFfmx7dE5W/2Y+3Ba2PbSThX2yhf93ejMDlsWMWIoZsaxkxFLOiGU9I5ZaRixbGbE0MWLZxYglzYhlHyOWTkYsRxmxdDNi6WXEMoMRy1xGLIsYsRQxYlnBiKWMEcs6Riw1jFi2MGJpZMSykxHLSEYsexmxjGHEcoQRy2FGLBMYsfQwYpnOiGUOI5aFjFgKGbEsZ8RSyohlLSOWakYsmxmxNDBi2cGIpY0Ryx5GLKMZsRxixDKeEcspRiwZRizTGLHMZsSygBFLASOWZYxYUoxY1jBiqWLEsokRywhGLNsZsbQyYtnNiGUUI5aDjFi6GLGcZMQymRHLVEYssxixzGfEks+IZSkjlhJGLKsZsVQyYtnIiKWeEcs2RiwtjFiuYMTSwYjlACOWcYxYTjBimcSIZQojln5GLFlGLAlGLEsYsSQZsaxixFLBiGUDI5Y6RiyXMWJpZsRyOSOWdkYs+xmxjGXEcpwRyzFGLBMZsfQxYpnJiGUeI5Y8gwXfi74NNHonG9+vzjPiw3fR6Xj6v/ZqD+kz/yeS9vE7uz7slht2yw275/q/dh8sMYMlloOlihFLGSOWckYsSUYshYxYEoxYKhixlDBiSTFiKWLEks+IpZIRSykjlmJGLAWMWOIXmOVc35Gi8BLQagx+pdH3O0pBo/tBZaDRs79y0GidVwVoeRY+ujbVgEZtvhY0Ktc60OgaWw8a9V1kX503o3ownO7b5ME5LdqP3y1q1f580NogTtLwe9ekpbW/CDS6L1IMWgf46ZfWO2HZUFqaQaM0t4BGedMKGuVhG2iU1yNBozJJg0bvYLSDRu/bIjt9z2SUJR3YBuicrP7NfLgtbANoJwv7ZAu/5zSKAUsBI5ZiRiyljFgqGbHkM2IpYsSSYsRSwoilghFLghFLISOWJCOWckYsZYxYqhix5A0TC40fKd46g8WX3RrDbs0w2W0w7DYMk90mw27TMNmV8h0eu1K+w2OXc/mmndqdmsH7BbTlugeUBpZ2pyyZHhXnSLdxZlScbY7jVHG0Qp5Q/hF7CsLx/2hbHedXHGxSvLTf6s9umP6WH5H+FgtHyzCmH/n+N7K2XUSsUgeE9WKqr9K2hFXqgLBKfRVWqa9+WKUOCKvUV2GV+uqHVeqAsEp9FVapr35YpQ4Iq9RXYZX66odV6oCwSn0VVqmvflilDgir1Fdhlfrqh1XqgLBKfRVWqa9+WKUOCKvUV2GV+uqHVeqAsEp9PX9WZbfZqd39U5KGXbXlejev2WMeqDhHu40zfI9sDPBTWslOCsKxLo5xnLY42KR4aR/5hFVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYhVVYLxbWFITnActoDywxgyVmyRfaRjBiqWbE0sCIpYgRSz4jllpGLDWMWKoYsSQZsRQyYkkwYqlnxFLHiKWREUsTI5ZKRizFjFgKGLHELzBLEhhioFF4Hmg0Rk6A1qn9+aCN1f4C0MZBOknr0v4i0MZrfzFoE8BPv93aPwK0idpfD9ok7a8DbbL214KW0f4a0Hq0vxq0Xu1vAK1P+xtBm6L9TaBN1f5K0KZpfxVo07W/A7QZ2t8O2kztHwlav/a3gEZliGVOZTgGNCrDTtCoDMeCRmU4DjQqwy7QqAzHg0ZliGVaov3doFEbmQhaaWxgozJVWpn2TwatXPszoFVofw9oVA69oFE59IFG5T8FNKonU0Gj+jQNNKp300Gj+jkDNKrHM0GjOkZlqsriKzWD4XQ+tlGyg22032JvpoWL/Ngn0TlZ/Zv5cFvYJ6GdLOyTrRJgmM6ApYARSzEjlkpGLE2MWBoZsdQxYqlnxJJgxFLIiCXJiKWKEUsNI5ZaRiz5jFiKGLE0MGKpZsQyghFLnsGCY+p+0Gg8j2PzPCM+nFPR8UU6fSnH6cM5UwzSiVsW/GRfsZS6ZcmkgKUU7JS7tdOLc73zSXM5sFS5ZenD+eT5sOB9/kq3LD0qzmq3cYbT5hrgp7SSnRSEY5nXOE5bHGxSvLSPfMLqnlWxlBmceC+kjAEfaZX+WHqTBovacrV1fL5Y75alD+8xnQ8LPi+qc8sS9jsj3MaZUXE2OI5TxdEIeUL5R+wpCMe1BI2O8ysONile2kc+YXXPin0F3vOn46oZ8JGGzymKjfxTc62rNayKF8cVt8HxNCdLwDFLawbDrq0ePM/xeKQX76HTlquPwr7b8dg08jjN4/i1x8M8IOPhehf2l3iNofxLwS+F47Wu1nF+xWNDn5NmYR/5hNU9q9qvMjjxmVwVAz7Syv2x9CYNFrXl6j9wnZvjsVEfPks8HxZcL+p4HNrjY5zm4dob9mVNkCeUf8SegnBcQ9TkOL/iYJPipX3kE1b3rNhX4NgKWS80H2k4X3PdvnDtBY4nn4HxJI7FboPj6b56Ao75s+rBOD6v/fhMuAR+6RpC9wxwLYfv+whkh+Kl/Rrgo2tIKWjkx7U/tYbmY14djw0dJ2Rhvw74iL8WNPLjWqJ6Q/NwbQqZ6w1m2h8BfMRfDxr5U8Bsa5s+5mXnapuNwEf8DRY+XMdF5+B4idp4OWjN2l8KGq3VwrVn9B4MzlfbtB/7MVr7hWve0tqPa+PyLOmg5xW4bo3mjrhujda/NINGz6xxnRn1E62g0Zy0DTTqV3DdGvUXaf1Lz05c3y+PAzvFS/vY/1W4tduL681oyzV+w/kBnYfrKcstzI7nz2FelRt8Zl+Zig0dg/tiSRosPyr/bHz4fo7juUJGsdQYLFTPcV7g+HqRsV0vKJ11kE+4Xj8bO/v64fu6UGBwkK0EHPOevrCWxbyMgcIlnWQrL3b2eEhtOK6l9obXq0bjOMXZ7DjfTA6y3wxaq4WzCThbjOMUZ5tbzl6TgzjbQEtbOFuBc6RxnKoPlMc/gDHmwprBcyh+HOc0G5qv8TyWQRb2Me8pfc3A4nj80uehfYT1jtplPqSjAcrmzH0FuJ9cXHN2ObRBPCMs4bTl6sNx7uiz36Q+sc5i18ecpBbSjtcN0hPgr4eLCl5fzLEgjqXP9by52TgHnzfXe04z3rvKwj7ZUvUkBXWK6oyPdozpxXxJQr5QeAtoVZbjqT1gv+O6XeZ6hoRzJdKwL8LnccTcaGg+7hHGY0OfD2ZhH6+n5pzLQ1vv83GfWsWBdZfSgW2YwrugXk+oObscsM/tt4TTlquvxPGd47lLBucB1FdWWOz6nH9QX0k2SE+AfyZ0dnjfh/KXmPE+FR6HfnM+n4Jw33MufGaZhX2yperJJKhT/dBXum7HmF7MF+wrKXwkaCnL8bh2h3h9PD8y52Hm9dV23cMxpoc2dFY+Uv7h/SLSKoHpGXhW73gdY5hXidjQvKJ9j2sW/8drBPAanAf5VmFhdv38Ple7LAc+0hIeWaKua7Dx4fdBXK9LsN13LwYGsut67YLt2TGlswbyCZ+vZ2ND7xWR7vO+foHBQbZw3H+5DqR7Ia7XEsbAVh6UD46L8b4ItTd83mCOQX3cpzc5yD6OjZotnA3A2WQcpzhb3HL2mhzE2QJam4WzGThbjeNwvn0crvdfgnshFD8+W2s0NF9zknON7zHvKX34TAX9xOe6fvtowyoOKtf82NnzaWy/10N53QhjesqbFojnbks4bee7vtfx2CBjPg/Ogg2063qchHZpzE82SMfn0B+DwR5eEyl/iRmfmeJx6G8wzsHrZY3nNON4KBs7e/2Vqic3Q526G8aqru/bY3oxX/C+AYXjOoYy43h8Zo590YV4Zo7r6/CZtPlMH5+Z43N+H/fEzvXMHNcm5Hpmjv2n4zF6n685EI1F8yFtOGam8E9CXf8U9I/mXC6cI1nCaTvftcc+xsBtEH8WbKDdkW7t9qBd6j/JBo4ryP80ZNjIQe+QubLacE0MHod+c36fgvBSz2k+15pRsqXqyeNQp56B/tP1vBrTi/mCa10ovBU08x0nfOaNfZGP68+5nvPj/S/S8JpaDn7i87FmA6/TxbFhWP/QM3Q+WRgbeq+BbCXgmN+CORu+F4vX8C/V+MsnLBvKJ8wjXI9TBUxXwz0m1/OiqM/88HmLOb7GdVE4l3P8XDusb60Gnzk3S4GG4+FWDyznWsPY6tnuufoE33YrDbuVw2T3XO+c+rZ7rnWIeG2gLc8zS8xgieVgaWbE0siIpZYRSwUjlkpGLCWMWIoYseQzYmlixDKCEUsDI5YaRixljFjKGbEkGbEUMmJJMGKpY8Tiez4ThaWKEUs1I5YUI5ZSRizFjFgKGLHELzBLMmb/zjyF43oeusdSAhquLSMtrf34Ll279uPz8A7tx/fwRmk/rr+i76Pj/TL6Pjq+a9Cp/fjMiL6Pjvdu6fvo+A5fl/bju3njtR+fm1F+YP7R9QrfpaPxOr5LR/UuDRpdd9tBo3lHB2jUfkaBRuMH/H48lQ1+P57KphM0Khv8fjyVDX4/nsqmCzQqG8ofla4x9YPhdD7WHbKD3z8fb7HXZeEiP7YVOierfzMfbgvbCtrJwj7Zwu+fj2XAUsCIpZgRSykjlhQjlmpGLFWMWOoZsdQxYkkwYilkxJJkxFLOiKWMEUsNI5YGRiwjGLE0MWLJZ8RSxIilhBFLJSOWCkYstYxYGhmxNDNiyRsmFpo/U7xdBouy2+nWbvg9P/wfcZrXd0L6yf4Y4HD8v4rhujDkSIPd0WB3lON8V3F0WNI/CtJP9juAo8MxR661y3gvidoolY+69n2mdpBrrFuuPfHY0Pp3W+zsfiIBx/xa7SDXZ2sH85DWoOF7/m2G5nvtLsVL+2TL9p4Q8uH3uOgcvIeYZzk3YdgoinkpnwyWj9rSsbPLB/u5wtjQtoX/P0rHPAdl+P26wfMcs4d/84j3G23XH8ftPXynjNpODOLHPGwHv60/7DCOozx1yNljcpD9NGhtFs524DTXqHt4TpEx2xeujcf1nq2WtIwCLsdrZHNeT1vA7gS3dnvx24OYJzGDhbYJwDLJLUv4fePuCCyTgGWiW5bw+8aT3cYZft844zhOFUcP5AnlH7GnIDwD+dXjOL/iYJPipX3kE1b3rIqlxeBMwnEtDPhIw/9ybjLyT12/v+tvbNhnGxua94VwbPifdYNc34Ox4TgjX/F5MOa167F/PDZ0LJCNnX1tKoG0dAKL43nYkLkoxSt2nZd52DRwXEV1D8ub7Pse3420cKSBg+yPBA7H47dwPDzBwmH7niSOVbrdcoTjSOTAcWQ32HU9Lok6RpoILI7HMyHLpAgsk4HF9XVIsWQisPQAS58Hlt4ILH3AMtUDy5QILFOBZboHlmkRWPD/YWd6YJkRgYXsq7EMtb9O0KgdtING9XECaFQvRoNG5dMBGuVTHmjEi2vj6D9q8T7VbENT+TfHSFPmw23h9ZDsULy0Pwf4Zmn/bH8sMzB+vC8zB2zOdZx+Fed8p3FODeeHCxxzqjgW6rjyoTzITgLCx8J4t0v7VX2ap8P7IZ4ZlnDacrWj+VAmi92mNbwmL4H4s2AD7S51a7cH7ca1IxukJ8A/HT6Eu3TQeyZ/iVm1n0WW49A/zzgnBeGLPKd5MXBkYZ9sqXrSDXVqBtybzTrmwfRivsyGfKHwuXDcQvDTsWnIt0VOOQfauON6H6Z9CeQ5xUt2sO7Nh/JYCG14gZFvKnyDJZy2XG0c690yt2kN2/hyiD8LNtDuCrd2e9AutXGyQXoC/Ouhja8Y9J7JX2JWbXyp5Tj0LzDOSUH4Us9pXgYcWdgnW6qeLIE6tQHauNvr40A9X2rJl4WQLxSO90mWgJ+OTUO+ue0bB9q443ofpn055DnlLdnBurcDymMXtOHFRr6p8OOWcNpytXGsdyvdpjVs46sg/izYQLur3drtQbvUxskG6QnwH4M2vnrQeyZ/iVm18RWW49C/2DgnBeErPKd5JXBkYZ9sqXqyG+rUcWjjbq+PA/V8hSVflkC+UDjeF1sOfjo2Dfnmtm8caOOO632Y9lWQ55S3ZAfr3rVQHtdDG15m5JsKv8sSTluuNo71bo3btIZtfC3EnwUbaHedW7s9aJfaONkgPQH+j0IbXzfoPZO/xKza+GrLcehfZpyTgvDVntO8BjiysE+2VD25CerUXdDGXc8dML2YL8shXygc77GuAj8dm4Z8c9s3DrRxx/U+TPtayHPKW7KDde/jUB6fgDa80si38Lt2lnDacrVxrHfr3aY1bOMbIP4s2EC7G93a7UG71MbJBukJ8H8a2vjGQe+Z/CVm1cbXWY5D/0rjnBSEr/Oc5vXAkYV9sqXqyYNQpx6HNu567oDpxXxZBflC4aPhuLXgp2PTkG9u+8aBNu643odp3wB5TnlLdrDuPQXl8TS04TVGvqnw5y3htOVq41jvNrlNa9jGN0P8WbCBdre4tduDdqmNkw3SE+B/Dtr4lkHvmfwlZtXGN1qOQ/8a45wUhG/0nOZNwJGFfbKl6snnoE49D23c9dwB04v5shbyhcI74LgN4Kdj05BvbvvGgTbuuN6Had8MeU55S3aw7n0VyuNFaMPrjXxT4a9awmnL1cax3m11m9awjV8G8WfBBtrd5tZuD9qlNk42SE+A/xVo49sGvWfyl5hVG99iOQ79641zUhC+xXOatwJHFvbJlqonX4M69Sq0cddzB0wv5ssGyBcKz4PjNoOfjk1DvrntGwfauON6H6b9Mshzyluyg3Xvm1Ae34I2vMnINxX+niWctlxtHOvddrdpDdv4Dog/CzbQ7k63dnvQLrVxskF6AvzvQhvfOeg9k7/ErNr4Nstx6N9knJOC8G2e07wdOLKwT7ZUPfkO1Kn3oI27njtgejFfNkO+UDh++7jZOF7VZ2oPuPbAdbvE6wLFS/vYX5OG8x+P74eE+YjvZZjvh+D7UOOA6TMX8dpS00/rafH9CbxPa3s/ZZRxnEqf4/eq+jy8OxGWN60Fyoe8ITsJCC+uHzyuBL5fRGnG+tBoCact1/UB1106fjcjg+u86fowyWLX8fsNQ9aX0/WBbJCeAH8DvJSI6wEpf4lZ1buJluPQ326cg2u6JnpOM66rzMI+rpUvgzpFdcbX2t+JlnzB//2hcHxHymd7Q/u4vq7FYMR3ILH/dL0uF9f/Ury0PxH4zP+6x/cgsC/B9yB8/5dGNnb2/2v5sltg2C0YJrtFht2iYbKbNOwmh8luyrCbGia7w1+v9k9RcdY4jjPq/9PiN7CrnbJkeopjg9+8O3Tg9JpTpw9cEwcm4nxV/5YAF87JE3BOvkUrtGjFFq3E0NSG/09SBn78H79ygxP/Gw6/rUlTPPy2JqUDv6NJ9un4otjZZeSsEPIgIZip6yAzVKaqDq1QwxTHBj+USX/4VKYzokJnTpVOaI1OnEqMuparjyepjzmpCYO6QKgJlbqAqYG1moSpC0k6NnChUzdX1YVXPUhRL8irwbUajKpBT1dsYNCtLpLqAqMuRmowoQZMajChrqpqUbp6CUEtRJ8aG1h8rhbfq5XVauG7WpiqFg6rBZJqUbVaQDlP5+382MCCF7WwSi1YUA/Gl8QGHmyqB2jqQa16AKJutKsHOupGqboht1bnnZq4b4gNFhwW4PO6VdGFe8/p0wdOXHk6ffpUes/+/enrj5w+nD513YGrDx4/df1/A/56UXghsgMA",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "events": [],
  "debug": {
    "debugSymbols": [
      "eJzt3cuu5EZ2heF3qbFgcF/iplcxPBDsNtBAQ21Ymgl696aAYp4jiFl0eUcyfiZj5IaRVVxkKFcEo/Ijf/vyj3/+50+//v2fP//y5cffviz/JunLj//+25df/uenn//4f/zy60//++uXH5cfvvzt5/9a/+/vP3z577//429ffpTff/jLp9Ql29dPrv+7lMenre58fP3A9uHl4y82/f0/fvgjSKYEKZQglRKkQYLoQgkilCBKCWKUIE4JQmlWpTSrUppVKc2qlGY1SrMapVmN0qxGaVajNKtRmtUozWqUZjVKsxqlWZ3SrE5pVqc0q1Oa1SnN6pRmdUqzOqVZndKsTmnWRGnWRGnWRGnWRGnWRGnWRGnWRGnWRGnWRGnWRGnWTGnWTGnWTGnWTGnWTGnWTGnWTGnWTGnWTGnWTGnWQmnWQmnWQmnWQmnWQmnWQmnWQmnWQmnWQmnWQmnWSmnWSmnWSmnWSmnWSmnWSmnWSmnWSmnWSmnWSmnWRmnWRmnWRmnWRmnWRmnWRmnWRmnWRmnWRmnWRmlWWSjVKgulW2WhlKsslHaVhVKvslD6VRZKwcpCaVhZKBUrC6ZjBdOxgulYwXSsYDpWMB3LMVkclMVRWRyWhXFZgoFZgpFZgqFZgrFZgsFZgtFZguFZgvFZggFaghFagiFagjFagkFaglFagmFagnFagoFagpFagqFagrFagsFagtFaguFagvFaggFbghFbgiFbgjFbgkFbglFbgmFbgnFbgoFbgpFbgqFbgrFbgsFbgtFbguFbgvFbggFcghFcgiFcgjFcgkFcglFcgmFcgnFcgoFcgpFcgqFcgrFcgsFcgtFcguFcgvFcggFdghFdgiFdgjFdgkFdglFdgmFdgnFdgoFdgpFdgqFdgrFdgsFdgtFdguFdgvFdggFeghFegiFegjFegkFeglFegmFegnFeinFeinFeinFeinFeulA6VjHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOSzHOyzDOyzDOyzDOyzDOyxZKxxrGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeRnGeTnGeTnGeTnGeTnGeflC6VjHOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOC/HOK+EcV4J47wSxnkljPNKC6VjE8Z5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeCeO8EsZ5JYzzShjnlTDOK2GcV8I4r4RxXgnjvBLGeSWM80oY55UwzithnFfCOK+EcV4J47wSxnkljPNKGOeVMM4rYZxXwjivhHFeGeO8MsZ5ZYzzyhjnlRdKx2aM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvDLGeWWM88oY55UxzitjnFfGOK+McV4Z47wyxnlljPPKGOeVMc4rY5xXxjivjHFeGeO8MsZ5ZYzzyhjnlTHOK2OcV8Y4r4xxXhnjvArGeRWM8yoY51UwzqsslI4tGOdVMM6rYJxXwTivgnFeBeO8CsZ5FYzzKhjnVTDOq2CcV8E4r4JxXgXjvArGeRWM8yoY51UwzqtgnFfBOK+CcV4F47wKxnkVjPMqGOdVMM6rYJxXwTivgnFeBeO8CsZ5FYzzKhjnVTDOq2CcV8E4r4JxXgXjvArGeRWM8yoY51UwzqtgnFfBOK+CcV4F47wKxnkVjPMqGOdVMM6rYJxXwTivgnFeBeO8CsZ5FYzzKjHntf6VjyQqHksS6tiuSUId2zVJqGO7Jgl1bNckoY7tmiTUsV2ThDq2a5JQx/ZMEnNeXZNgOjbmvLomwXRszHl1TYLp2Jjz6poE07Ex59U1CaZjY86raxJMx8acV9ckmI6NOa+uSTAdG3NeXZNgOjbmvLomwXRszHl1TYLp2Jjz6poE07Ex59U1CaZjY86raxJMx8acV9cklI6tMefVNQmlY2vMeXVNQunYulA6tsacV9cklI6tMefVNQmlY2vMefVMEnNeXZNgOjbmvLomwXRszHl1TYLp2Jjz6poE07Ex59U1CaZjY86raxJMx8acV9ckmI6NOa+uSTAdG3NeXZNgOjbmvLomwXRszHl1TYLp2Jjz6poE07Ex59U1CaZjY86raxJMx8acV9ckmI6NOa+uSTAdG3NeXZNgOjbmvLomwXRszHl1TYLp2Jjz6poE07Ex59U1CaZjY86raxJMx8acV9ckmI6NOa+uSTAdG3NeXZNgOjbmvLomwXQsxnlVjPOqGOdVMc6rYpxXxTivinFeFeO8KsZ5VYzzqhjnVTHOq2KcV8U4r4pxXhXjvCrGeVWM86oY51UxzqtinFfFOK+KcV4V47wqxnlVjPOqGOdVMc6rYpxXxTivinFeFeO8KsZ5VYzzqhjnVTHOq2KcV8U4r4ZxXg3jvBrGeTWM82oLpWMbxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV4N47waxnk1jPNqGOfVMM6rYZxXwzivhnFeDeO8GsZ5NYzzahjn1TDOq2GcV8M4r4ZxXg3jvBrGeTWM82oY59UwzqthnFfDOK+GcV6yYKDXGoXSsmsUSs2uUSg9u0ahFO0ahdK0axRK1a5RKF27RqGU7RqF07YY8rVG4bQtBn2tUThti2FfaxRO22Lg1xqF07YY+rVG4bQtBn+tUThti+FfaxRO22IA2BqF07YYArZG4bQtBoGtUThti2FgaxRO22Ig2BqF07YYCrZG4bQtBoOtUThti+FgaxRO22JA2BqF07YYErZG4bQtBoWtUThti2FhaxRO22Jg2BqF07YYGrZG4bQtBoetUThti+FhaxRO22KA2BqF07YYIrZG4bQtBomtUThti2FiaxRO22Kg2BqF07YYKrZG4bQtBoutUThti+FiaxRO22LA2BqF07YYMrZG4bQtBo2tUThti2FjaxRO22Lg2BqF07YYOrZG4bQtBo+tUThti+FjaxRO22IA2RqF07YYQrZG4bQtBpGtUThti2FkaxRO22Ig2RqF07YYSrZGwbStcCyZcCyZcCyZcCyZLJi2FY4lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lE44lU44lU44lU44lU44l0wXTtsqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMqxZMaxZMaxZMaxZMaxZLZg2tY4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw4lsw5lsw5lsw5lsw5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s/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/NymZ2Xy+y8XGbn5TI7L5fZebnMzstldl4us/MKmZ1XyOy8QmbnFTI7r3hTOWNDZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZnVfI7LxCZucVMjuvkNl5hczOK2R2XiGz8wqZndeQ2XkNmZ3XkNl5DZmd13hTOWOHzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvI7LyGzM5ryOy8hszOa8jsvIbMzmvK7LymzM5ryuy8pszOa76pnLFTZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm5zVldl5TZuc1ZXZeU2bnNWV2XlNm57Vkdl5LZue1ZHZeS2bntd5Uztgls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz81oyO68ls/NaMjuvJbPzWjI7ryWz89oyO68ts/PaMjuvLbPz2m8qZ+yW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3Xltl5bZmd15bZeW2ZndeW2XltmZ3XrndefsXHJa65vvs8f0+V52GbKs+uNlWeM22qPBPaVHn/tqnyXmtT5X3RpsoON6mr3ry0KdKNq96StCnSjeuNdOOq9xRtinTjqncKbYp046rf/+9S9bv6bQp1o34Hvk2hbtTvlrcp1I36ne02hbpRvwvdplA36neM2xTqRv3ubptC3ajfiW1TqBv1u6ZtCnWjfoezTaFu1O9GtinUjfqdwzaFulG/y9emUDfqd+TaFOpG/e5Zm0LdqN/palOoG/W7Um0KdaN+B6lNoW7U7/a0KdSN+p2ZNoW6Ub+L0qZQN+p3PNoU6kb97kSbQt2o30loU6gb9bP+NoW6UT9Db1OoG/Wz6TaFulE/821TqBv1s9Q2hbpRP6NsU6gb9bO/NoW6UT9Ta1OoG/WzqjaFulE/A2pTqBv1s5U2hbpRP7NoU6gb9bOANoW6URt7m0LdqO26TaFu1CbcplA3amttU6gbyEUv5KIXctELueiFXPRCLnohF72QiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7loIhdN5KKJXDSRiyZy0UQumshFE7movSEYvWOkHXeM1OOOkX7cMVKQO0YacsdIRe4Y6cgdIyW5Y6wliEjvGGsJQtI7xlqCmPSOsZYgKL1jrCWISu8YawnC0jvGWoK49I6xliAwvWOsJYhM7xhrCULTO8Zagtj0jrGWIDi9Y6wliE7vGGsJwtM7xlqC+PSOsZYgQL1jrCWIUO8YawlC1DvGWoIY9Y6xliBIvWOsJYhS7xhrCcLUO8Zagjj1jrGWIFC9Y6wliFTvGGsJQtU7xlqCWPWOsZYgWL1jrCWIVu8YawnC1TvGWoJ49Y6xliBgvWOsJYhY7xhrCULWO8Zagpj1jrGWIGi9Y6wliFrvGGsJwtY7xlqCuPWOsZYgcL1jrCWIXO8YawlC1zvGWoLY9Y6xliB4vWOsJYhe7xhqiTF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL0as1dj9mrMXo3ZqzF7NWavxuzVmL06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN7dWavzuzVmb06s1dn9urMXp3ZqzN79QPqrD3fYzu+fVf7/parP2Wfqz9mn6vb3OYOsNPn6j73ubrQfa5udJ+rK93n6k73OdiXg+/0OdiXg/C0uQPx9DnYlwPy9DnYlwPz9DnYlwP09DnYlwP19DnYlwP29DnYlwP39DnYlwP49DnYlwP59DnYlwP69DnYlwP79DnYlwP89DnYlwP99DnYlwP+9DnYlwP/9DnYlwMA9TnYlwMB9TnYlwMC9TnYlwMD9TnYlwME9TnWlzhQUJ9jfYkDBvU51pc4cFCfY32JAwj1OdaXOJBQn4N9OaBQn4N9ObBQn4N9OcBQn4N9OdBQn4N9OeBQn4N9OfBQn4N9OQBRn4N9ORBRn4N9OSBRn4N9OTBRn4N9Obyk1+dgXw6v6fU52JfDi3p9Dvbl8Kpen4N9Obys1+dgXw6v6/U52JfDC3t9Dvbl8Mpen4N9gb4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9N6DvBvTdgL4b0HcD+m5A3w3ouwF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13QN8d0HcH9N0BfXdA3x3Qdwf03QF9d0DfHdB3B/TdAX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdC353Qdyf03Ql9d0LfndB3J/TdCX13Qt+d0Hcn9N0JfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d0HcX9N0FfXdB313Qdxf03QV9d0HfXdB3F/TdBX13Qd9d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vhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8G9N2AvhvQdwP6bkDfDei7AX03oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO8u6LsL+u6Cvrug7y7ouwv67oK+u6DvLui7C/rugr67oO9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh727ouxv67oa+u6Hvbui7G/ruhr67oe9u6Lsb+u6Gvruh717Qdy/ouxf03Qv67gV994K+e0HfvaDvXtB3L+i7F/TdC/ruBX33gr57Qd+9oO9e0Hcv6LsX9N0L+u4FffeCvntB372g717Qdy/ouxf03Qv67gV994K+e0HfvaDvXtB3L+i7F/TdC/ruBX33gr57Qd+9oO9e0Hcv6LsX9N0L+u4FffeCvntB372g717Qdy/ouxf03Qv67gV994K+e0HfvaDvXtB3L+i7F/TdC/ruBX33gr57Qd+9oO9e0Hcv6LsX9N0L+u4FffeCvntB372g717Qdy/ouxf03Qv67gV994K+e0HfvaDvXtB3L+i7F/TdC/ruBX33gr57Qd+9oO9e0Hcv6LsX9N0L+u4FffeCvntB372g717Qdy/ouxf03Qv6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03oe8m9N2EvpvQdxP6bkLfTei7CX03me/GG/PdO4f6cudQX+4c6sudQ325c6gvdw715c6hvtw51Jc7B/vCfPfOwb4w371zsC/Md+8c7Avz3TsH+8J8987BvjDfvXOwL8x37xzsC/PdOwf7wnz3zsG+MN+9c7AvzHfvHOwL8907B/vCfPfOwb4w371zsC/Md+8c7Avz3TsH+8J8987BvjDfvXOwL8x37xzsC/PdOwf7wnz3zsG+MN+9c7AvzHfvHOwL8907B/vCfPfOwb4w371zsC/Md+8c7Avz3TsH+8J8987BvjDfvXOwL8x37xzsC/PdOwf7wnz3zsG+MN+9c7AvzHfvHOwL8907B/vCfPfOwb4w371zsC/Md+8c7Avz3TsH+8J8987BvjDfvXOwL8x37xzsC/PdOwf7wnz3zrG+GPRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5B3zXouwZ916DvGvRdg75r0HcN+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRdh77r0Hcd+q5D33Xouw5916HvOvRd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zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdl8vsvFxm5+UyOy+X2Xm5zM7LZXZeLrPzcpmdV5PZeTWZnVeT2Xk1mZ1X+1I5Y5vMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOq8nsvJrMzqvJ7LyazM6ryey8mszOK2R2XiGz8wqZnVfI7LziS+WMDZmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeIbPzCpmdV8jsvEJm5xUyO6+Q2XmFzM4rZHZeKbPzSpmdV8rsvFJm55VfKmdsyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/NKmZ1Xyuy8UmbnlTI7r5TZeaXMzitldl4ps/MqmZ1Xyey8SmbnVTI7r/pSOWNLZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVfJ7LxKZudVMjuvktl5lczOq2R2XiWz8yqZnVeX2Xl1mZ1Xl9l5dZmdV/9SOWO7zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8uszOq8vsvLrMzqvL7Ly6zM6ry+y8+mc7r/Vf+eNO3OKzO/nojH31Tj46Y1+9k4/O2Ffv5KMz9s07+Wzn9eqdfHTGvnonH52xr97JR2fsq3fy0Rn76p3InLGf7bxevROZM/aznderdyJzxn6283r1TmTO2M92Xq/eicwZ+9nO69U7kTljP9t5vXonMmfsZzuvV+9E5oz9bOf16p3InLGf7bxevROZM/aznderdyJzxn6283r1TmTO2M92Xq/eicwZ+9nO69U7kTljP9t5vXonMmfsZzuvV+9E5oz9bOf16p3InLGf7bxevROVM3Z8tvN69U5Uztjx2c7r1TtROWPHl8oZOz7beb16Jypn7Phs5/XqnaicseOzndebd/LZzuvVO5E5Yz/beb16JzJn7Gc7r1fvROaM/Wzn9eqdyJyxn+28Xr0TmTP2s53Xq3cic8Z+tvN69U5kztjPdl6v3onMGfvZzuvVO5E5Yz/beb16JzJn7Gc7r1fvROaM/Wzn9eqdyJyxn+28Xr0TmTP2s53Xq3cic8Z+tvN69U5kztjPdl6v3onMGfvZzuvVO5E5Yz/beb16JzJn7Gc7r1fvROaM/Wzn9eqdyJyxn+28Xr0TmTP2s53Xq3cic8Z+tvN69U5kzliZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XkNmZ3XkNl5DZmd15DZeQ2ZndeQ2XlNmZ3XlNl5TZmd15TZec0vlTN2yuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LymzM5ryuy8pszOa8rsvKbMzmvK7LzsS2botW5F5ZRdt6JyzK5bUTln162oHLTrVlRO2nUrKkftuhWVs3bdisphu25F57SVmXytW9E5bWVGX+tWdE5bmdnXuhWd01Zm+LVuRee0lZl+rVvROW1lxl/rVnROW5n517oVndNWZgC2bkXntJWZgK1b0TltZUZg61Z0TluZGdi6FZ3TVmYItm5F57SVmYKtW9E5bWXGYOtWdE5bmTnYuhWd01ZmELZuRee0lZmErVvROW1lRmHrVnROW5lZ2LoVndNWZhi2bkXntJWZhq1b0TltZcZh61Z0TluZedi6FZ3TVmYgtm5F57SVmYitW9E5bWVGYutWdE5bmZnYuhWd01ZmKLZuRee0lZmKrVvROW1lxmLrVnROW5m52LoVndNWZjC2bkXntJWZjK1b0TltZUZj61Z0TluZ2di6FZ3TVmY4tm5F57SVmY6tW9E5bWXGY+tWdE5bmfnYuhWd01ZmQLZuRee0lZmQrVvROW1lRmTrVnROW5kZ2boVndNWZki2bkXntJWZkq1bkTltTWdLZjpbMtPZkpnOlsy+ZE5b09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0tmOlsy09mSmc6WzHS2ZKazJTOdLZnpbMlMZ0vmOlsy19mSuc6WzHW2ZP4lc9q6zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6WzLX2ZK5zpbMdbZkrrMlc50tmetsyVxnS+Y6W7KmsyVrOluyprMlazpbsvYlc9o2nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnT2ZI1nS1Z09mSNZ0tWdPZkjWdLVnobMlCZ0sWOluy0NmSxZfMaRs6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKFzpYsdLZkobMlC50tWehsyUJnSxY6W7LQ2ZKF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ux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+m6Hvtuh73boux36boe+26Hvdui7Hfpuh77boe926Lsd+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oC+O6DvDui7A/rugL47oO8O6LsD+u6Avjug7w7ouwP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7E/ruhL47oe9O6LsT+u6Evjuh707ouxP67oS+O6HvTui7k/lu+2K+u3KoLyuH+rJyqC8rh/qycqgvK4f6snKoLyuH+rJysC/Md1cO9oX57srBvjDfXTnYF+a7Kwf7wnx35WBfmO+uHOwL892Vg31hvrtysC/Md1cO9oX57srBvjDfXTnYF+a7Kwf7wnx35WBfmO+uHOwL892Vg31hvrtysC/Md1cO9oX57srBvjDfXTnYF+a7Kwf7wnx35WBfmO+uHOwL892Vg31hvrtysC/Md1cO9oX57srBvjDfXTnYF+a7Kwf7wnx35WBfmO+uHOwL892Vg31hvrtysC/Md1cO9oX57srB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"
    ],
    "fileMap": {
      "1": {
        "source": "mod types;\n\ncontract CoinToss {\n    use dep::aztec::context::Context;\n    use crate::types::bet_note::{BetNote, BetNoteMethods, BET_NOTE_LEN};\n    use crate::types::config_note::{ConfigNote, ConfigNoteMethods, CONFIG_NOTE_LEN};\n\n    use dep::aztec::note::{\n        note_getter_options::NoteGetterOptions,\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        note_viewer_options::NoteViewerOptions,\n        utils as note_utils\n    };\n\n    use dep::std::option::Option;\n\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::{\n        get_public_key::get_public_key,\n        rand::rand\n    };\n    use dep::aztec::state_vars::{\n        public_state::PublicState,\n        map::Map,\n        set::Set,\n        singleton::Singleton,\n        immutable_singleton::ImmutableSingleton\n    };\n    use dep::aztec::selector::compute_selector;\n\n    use dep::aztec::types::type_serialization::field_serialization::{ FieldSerializationMethods, FIELD_SERIALIZED_LEN};\n    use dep::aztec::types::type_serialization::aztec_address_serialization::{AztecAddressSerializationMethods, AZTEC_ADDRESS_SERIALIZED_LEN};\n\n    use dep::aztec::types::address::AztecAddress;\n\n\n    global CONFIG_NOTE_SLOT = 1;\n    global BETS_SLOT = 2;\n\n    // TODO: add slow update tree to make the switch from private to public\n    struct Storage {\n        config: ImmutableSingleton<ConfigNote, CONFIG_NOTE_LEN>,\n        bets: Set<BetNote, BET_NOTE_LEN>,\n    }\n\n    impl Storage {\n        fn init(context: Context) -> Self {\n            Storage {\n                config: ImmutableSingleton::new(\n                    context,\n                    CONFIG_NOTE_SLOT,\n                    ConfigNoteMethods,\n                ),\n                bets: Set::new(context, BETS_SLOT, BetNoteMethods)\n            }\n        }\n    }\n\n    // Constructs the contract.\n    #[aztec(private)]\n    fn constructor(divinity: AztecAddress, private_oracle: AztecAddress, house: AztecAddress, bet_amount: Field) {\n        let mut config_note = ConfigNote::new(divinity, private_oracle, house, bet_amount);\n        storage.config.initialize(&mut config_note, Option::none(), false);\n    }\n\n    #[aztec(private)]\n    fn create_bet(bet: bool) {\n        let sender = AztecAddress::new(context.msg_sender());\n        let house = storage.config.get_note().house;\n        let address_this = AztecAddress::new(context.this_address()).address;\n\n        let mut user_bet: BetNote = BetNote::new(sender, bet);\n        storage.bets.insert(&mut user_bet, true);\n\n        emit_encrypted_log(\n            &mut context,\n            address_this,\n            BETS_SLOT,\n            get_public_key(house.address),\n            user_bet.serialize(),\n        );\n    }\n\n    // Returns the divinity address\n    unconstrained fn get_config_unconstrained() -> ConfigNote {\n        storage.config.view_note()\n    }\n\n    unconstrained fn get_user_bets_unconstrained(user: AztecAddress, start_offset: u32) -> [Option<BetNote>; 10] {\n        // MAX_NOTES_PER_PAGE == 10\n        // https://github.com/AztecProtocol/aztec-packages/blob/2d498b352364debf59af940f0a69c453651a4ad0/yarn-project/aztec-nr/aztec/src/constants_gen.nr#L53\n\n        // create the filter - limiting to 10 for future compatibility\n        let user_bets_getter_option = NoteViewerOptions::new().select(0, user.address).set_offset(start_offset);\n\n        // filter the notes and return the answer-\n        storage.bets.view_notes(user_bets_getter_option)\n    }\n\n    // Computes note hash and nullifier.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; CONFIG_NOTE_LEN]) -> [Field; 4] {\n        let note_header = NoteHeader::new(contract_address, nonce, storage_slot);\n\n        if(storage_slot == BETS_SLOT) {\n            note_utils::compute_note_hash_and_nullifier(BetNoteMethods, note_header, preimage)\n        } else {\n            note_utils::compute_note_hash_and_nullifier(ConfigNoteMethods, note_header, preimage)\n        }\n    }\n}",
        "path": "/Users/ngng/code/ng/aztec-coin-toss/src/main.nr"
      },
      "3": {
        "source": "mod poseidon;\nmod mimc;\n\n#[foreign(sha256)]\npub fn sha256<N>(_input: [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\npub fn blake2s<N>(_input: [u8; N]) -> [u8; 32] {}\n\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint {\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\npub fn __pedersen_commitment_with_separator<N>(_input: [Field; N], _separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\npub fn pedersen_hash<N>(input: [Field; N]) -> Field {\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(_input: [Field; N], _separator: u32) -> Field {}\n\npub fn hash_to_field<N>(_input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = _input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\npub fn keccak256<N>(_input: [u8; N], _message_size: u32) -> [u8; 32] {}\n\n",
        "path": "std/hash.nr"
      },
      "32": {
        "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n",
        "path": "std/option.nr"
      },
      "35": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\nuse crate::hash::pedersen_hash;\n\n// docs:start:private-global-variables\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n// docs:end:private-global-variables\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\n// docs:start:public-global-variables\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n// docs:end:public-global-variables\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\n// docs:start:contract-deployment-data\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n// docs:end:contract-deployment-data\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\n// docs:start:private-context-inputs\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    private_global_variables: PrivateGlobalVariables,\n}\n// docs:end:private-context-inputs\n\n// PublicContextInputs are expected to be provided to each public function\n// docs:start:public-context-inputs\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n// docs:end:public-context-inputs\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n    function_selector: Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.function_selector,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\n// docs:start:historic-block-data\nstruct HistoricBlockData {\n    note_hash_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n// docs:end:historic-block-data\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    pub fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.note_hash_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    pub fn empty() -> Self {\n        Self { note_hash_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    pending_read_requests: [Field; crate::abi::MAX_PENDING_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        pedersen_hash(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.pending_read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    pub fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    pub fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)\n    }\n\n    pub fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    pub fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize());\n        inputs.push(self.prover_address);\n\n        pedersen_hash(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n\n    pub fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hasher {\n    pub fn new()-> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n\n    pub fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n",
        "path": "/aztec/abi.nr"
      },
      "36": {
        "source": "use crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\nuse crate::hash::pedersen_hash;\n\npub fn compute_address(pub_key_x: Field, pub_key_y: Field, partial_address: Field) -> Field {\n  pedersen_hash([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)\n}",
        "path": "/aztec/address.nr"
      },
      "38": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_PENDING_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\nuse dep::std::option::Option;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n    pending_read_requests: BoundedVec<Field, MAX_PENDING_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n            pending_read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            pending_read_requests: self.pending_read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    pub fn push_pending_read_request(&mut self, pending_read_request: Field) {\n        self.pending_read_requests.push(pending_read_request);\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    // We never push a zero nullified_commitment as zero is used to indicate the end\n    // of a field array in private kernel. This routine transparently replaces a\n    // zero value into the special placeholder: EMPTY_NULLIFIED_COMMITMENT.\n    pub fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        let mut non_zero_nullified = nullified_commitment;\n        if (non_zero_nullified == 0) {\n            non_zero_nullified = EMPTY_NULLIFIED_COMMITMENT;\n        }\n        self.nullified_commitments.push(non_zero_nullified);\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, content: Field) \n    // docs:end:context_message_portal\n    {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        msg_key: Field,\n        content: Field,\n        secret: Field\n    ) \n    // docs:end:context_consume_l1_to_l2_message\n    {\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, self.this_address(), msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[12],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 13),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 17),\n                pending_read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 49),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 81),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 97),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 113),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 129),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 133),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 137),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 139),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 141),\n                encrypted_log_preimages_length: fields[143],\n                unencrypted_log_preimages_length: fields[144],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    note_hash_tree_root : fields[145],\n                    nullifier_tree_root : fields[146],\n                    contract_tree_root : fields[147],\n                    l1_to_l2_messages_tree_root : fields[148],\n                    blocks_tree_root : fields[149],\n                    public_data_tree_root: fields[150],\n                    global_variables_hash: fields[151],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[152], fields[153]),\n                    constructor_vk_hash : fields[154],\n                    function_tree_root : fields[155],\n                    contract_address_salt : fields[156],\n                    portal_contract_address : fields[157],\n                },\n                chain_id: fields[158],\n                version: fields[159],\n            },\n            is_execution_request: fields[160] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    function_selector: fields[8], // practically same as fields[1]\n                    is_delegate_call : fields[9] as bool,\n                    is_static_call : fields[10] as bool,\n                    is_contract_deployment: fields[11] as bool,\n                },\n                args_hash: fields[12],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    pub fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    pub fn selector(self) -> Field {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    pub fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    pub fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context {\n            private: Option::some(context),\n            public: Option::none()\n        }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context {\n            public: Option::some(context),\n            private: Option::none()\n        }\n    }\n\n    pub fn none() -> Context {\n        Context {\n            public: Option::none(),\n            private: Option::none()\n        }\n    }\n}",
        "path": "/aztec/context.nr"
      },
      "39": {
        "source": "use dep::std::hash::{pedersen_hash_with_separator, sha256};\nuse crate::constants_gen::{\n  GENERATOR_INDEX__SIGNATURE_PAYLOAD,\n  GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET,\n};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n  let sha256_hashed = sha256(bytes_to_hash);\n\n  // Convert it to a field element\n  let mut v = 1;\n  let mut high = 0 as Field;\n  let mut low = 0 as Field;\n\n  for i in 0..16 {\n      high = high + (sha256_hashed[15 - i] as Field) * v;\n      low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n      v = v * 256;\n  }\n\n  // Abuse that a % p + b % p = (a + b) % p and that low < p\n  let hash_in_a_field = low + high * v;\n\n  hash_in_a_field\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n  // TODO(#1205) This is probably not the right index to use\n  pedersen_hash([secret], GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET)\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n  pedersen_hash_with_separator(inputs, hash_index)\n}",
        "path": "/aztec/hash.nr"
      },
      "40": {
        "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse crate::types::point::Point;\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(\n    context: &mut PublicContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/aztec/log.nr"
      },
      "45": {
        "source": "use crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n    broadcast: bool,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialize = note_interface.serialize;\n    let serialized_note = serialize(*note);\n    assert(notify_created_note(storage_slot, serialized_note, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        let broadcast = note_interface.broadcast;\n        broadcast(context, storage_slot, *note);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(nullifier, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/aztec/note/lifecycle.nr"
      },
      "46": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(\n    fields: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        assert(fields[select.field_index] == select.value, \"Mismatch return note field.\");\n    }\n}\n\nfn check_notes_order<N>(fields_0: [Field; N], fields_1: [Field; N], sorts: BoundedVec<Option<Sort>, N>) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index] as u120 < fields_1[sort.field_index] as u120;\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let serialize = note_interface.serialize;\n            let fields = serialize(note);\n            check_note_header(*context, storage_slot, note_interface, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    };\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/aztec/note/note_getter.nr"
      },
      "48": {
        "source": "use crate::hash::pedersen_hash;\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\npub fn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([storage_slot, note_hash], 0)\n}\n\npub fn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)\n}\n\npub fn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)\n}\n",
        "path": "/aztec/note/note_hash.nr"
      },
      "52": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\npub fn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\npub fn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386)\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\npub fn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    serialized_note: [Field; S],\n) -> [Field; 4] {\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    let mut note = deserialize(arr_copy_slice(serialized_note, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/aztec/note/utils.nr"
      },
      "59": {
        "source": "use crate::types::point::Point;\nuse crate::address::compute_address;\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: Field) -> [Field; 3] {\n  get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: Field) -> Point {\n  let result = get_public_key_and_partial_address_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = compute_address(pub_key_x, pub_key_y, partial_address);\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/aztec/oracle/get_public_key.nr"
      },
      "61": {
        "source": "\n\n#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n",
        "path": "/aztec/oracle/rand.nr"
      },
      "64": {
        "source": "use dep::std::option::Option;\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field,\n) -> Field {\n    notify_created_note_oracle(storage_slot, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(\n    _nullifier: Field,\n    _inner_note_hash: Field,\n) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(\n    nullifier: Field,\n    inner_note_hash: Field,\n) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _sort_by: [u8; N],\n    _sort_order: [u2; N],\n    _limit: u32,\n    _offset: u32,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    sort_by: [u8; N],\n    sort_order: [u2; N],\n    limit: u32,\n    offset: u32,\n    mut placeholder_fields: [Field; S],\n)-> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, return_size, placeholder_fields)\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    sort_by: [u8; M],\n    sort_order: [u2; M],\n    limit: u32,\n    offset: u32,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n) -> [Option<Note>; S] {\n    let fields = get_notes_oracle_wrapper(storage_slot, num_selects, select_by, select_values, sort_by, sort_order, limit, offset, placeholder_fields);\n    let num_notes = fields[0] as u32;\n    let contract_address = fields[1];\n    let deserialize = note_interface.deserialize;\n    let set_header = note_interface.set_header;\n    for i in 0..placeholder_opt_notes.len() {\n        if i as u32 < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: Field = 2; // num_notes & contract_address.\n            let extra_preimage_length: Field = 2; // nonce & is_transient.\n            let read_offset: Field = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = deserialize(serialized_note);\n            set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    };\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(\n    _inner_nullifier: Field,\n) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}",
        "path": "/aztec/oracle/notes.nr"
      },
      "66": {
        "source": "use crate::types::point::Point;\nuse crate::constants_gen::NUM_FIELDS_PER_SHA256;\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: Field,\n    _storage_slot: Field,\n    _encryption_pub_key: Point,\n    _preimage: [Field; N],\n)  -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    preimage: [Field; N],\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [emit_encrypted_log_oracle(\n        contract_address,\n        storage_slot,\n        encryption_pub_key,\n        preimage,\n    ), 0]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(_contract_address: Field, _event_selector: Field, _message: T)  -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(contract_address: Field, event_selector: Field, message: T) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}",
        "path": "/aztec/oracle/logs.nr"
      },
      "71": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\nuse crate::context::{PrivateContext, Context};\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::singleton::compute_singleton_initialization_nullifier;\n\n// docs:start:struct\nstruct ImmutableSingleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        ImmutableSingleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note, \n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(\n            context,\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note(self) -> Note {\n        let context = self.context.unwrap();\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/aztec/state_vars/immutable_singleton.nr"
      },
      "74": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::constants_gen::{MAX_NOTES_PER_PAGE, MAX_READ_REQUESTS_PER_CALL};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n};\n\n// docs:start:struct\nstruct Set<Note, N> {\n    context: Context,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n// docs:end:struct\n\nimpl<Note, N> Set<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Set {\n            context,\n            storage_slot,\n            note_interface,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:insert\n    pub fn insert(self,\n        note: &mut Note,\n        broadcast: bool,\n    ) {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n            broadcast,\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(\n            self.context.public.unwrap(),\n            self.storage_slot,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:insert_from_public\n    \n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use Set.get_notes() and Set.remove() in your contract to verify and remove a note.\");\n    }\n\n    // docs:start:remove\n    pub fn remove(self, note: Note) {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_read_or_nullify(self.note_interface, note);\n        let has_been_read = context.read_requests.any(|r| r == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(\n            context,\n            note,\n            self.note_interface,\n        );\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n    ) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(\n            self.context.private.unwrap(),\n            storage_slot,\n            self.note_interface,\n            options,\n        );\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n        view_notes(self.storage_slot, self.note_interface, options)\n    }\n    // docs:end:view_notes\n}\n",
        "path": "/aztec/state_vars/set.nr"
      },
      "75": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{EMPTY_NULLIFIED_COMMITMENT, GENERATOR_INDEX__INITIALIZATION_NULLIFIER};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note},\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::{\n    get_secret_key::get_secret_key,\n    notes::check_nullifier_exists,\n};\nuse crate::hash::pedersen_hash;\n\npub fn compute_singleton_initialization_nullifier(storage_slot: Field, owner: Option<Field>) -> Field {\n    if owner.is_some() {\n        let secret = get_secret_key(owner.unwrap_unchecked());\n        pedersen_hash(\n            [storage_slot, secret.low, secret.high],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    } else {\n        pedersen_hash(\n            [storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\n// docs:start:struct\nstruct Singleton<Note, N> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    compute_initialization_nullifier: fn (Field, Option<Field>) -> Field,\n}\n// docs:end:struct\n\nimpl<Note, N> Singleton<Note, N> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        note_interface: NoteInterface<Note, N>,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Singleton {\n            context: context.private,\n            storage_slot,\n            note_interface,\n            compute_initialization_nullifier: compute_singleton_initialization_nullifier,\n        }\n    }\n    // docs:end:new\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self, owner: Option<Field>) -> bool {\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize(\n        self,\n        note: &mut Note,\n        owner: Option<Field>,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let compute_initialization_nullifier = self.compute_initialization_nullifier;\n        let nullifier = compute_initialization_nullifier(self.storage_slot, owner);\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(\n        self,\n        new_note: &mut Note,\n        broadcast: bool,\n    ) {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note, self.note_interface);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, self.note_interface, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note(self, broadcast: bool) -> Note {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot, self.note_interface);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note, self.note_interface);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, self.note_interface, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n",
        "path": "/aztec/state_vars/singleton.nr"
      },
      "79": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: Field) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if (!exceeded_len) {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n\n#[test]\nfn test_vec_push_pop() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    assert(vec.len == 0);\n    vec.push(2);\n    assert(vec.len == 1);\n    vec.push(4);\n    assert(vec.len == 2);\n    vec.push(6);\n    assert(vec.len == 3);\n    let x = vec.pop();\n    assert(x == 6);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test]\nfn test_vec_push_array() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    assert(vec.len == 2);\n    assert(vec.get(0) == 2);\n    assert(vec.get(1) == 4);\n}\n\n#[test(should_fail)]\nfn test_vec_get_out_of_bound() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2, 4]);\n    let _x = vec.get(2);\n}\n\n#[test(should_fail)]\nfn test_vec_get_not_declared() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    vec.push_array([2]);\n    let _x = vec.get(1);\n}\n\n#[test(should_fail)]\nfn test_vec_get_uninitialized() {\n    let mut vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n    let _x = vec.get(0);\n}\n\n#[test(should_fail)]\nfn test_vec_push_overflow() {\n    let mut vec: BoundedVec<Field, 1> = BoundedVec::new(0);\n    vec.push(1);\n    vec.push(2);\n}\n\n#[test]\nfn test_vec_any() {\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(0);\n    vec.push_array([2, 4, 6]);\n    assert(vec.any(|v| v == 2) == true);\n    assert(vec.any(|v| v == 4) == true);\n    assert(vec.any(|v| v == 6) == true);\n    assert(vec.any(|v| v == 3) == false);\n}\n\n#[test]\nfn test_vec_any_not_default() {\n    let default_value = 1;\n    let mut vec: BoundedVec<Field, 3> = BoundedVec::new(default_value);\n    vec.push_array([2, 4]);\n    assert(vec.any(|v| v == default_value) == false);\n}",
        "path": "/aztec/types/vec.nr"
      },
      "85": {
        "source": "pub fn arr_copy_slice<T, N, M>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: Field,\n) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n\npub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() as u32 < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}",
        "path": "/aztec/utils.nr"
      },
      "87": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n        utils::compute_note_hash_for_read_or_nullify,\n    },\n    oracle::{\n        rand::rand,\n        get_secret_key::get_secret_key,\n        get_public_key::get_public_key\n    },\n\n    log::emit_encrypted_log,\n    context::PrivateContext,\n    types::{\n        address::AztecAddress,\n    }\n};\n\nstruct BetNote {\n    owner: AztecAddress,\n    randomness: Field,\n    bet: bool, // Heads is 0 (False). Tails is 1 (True).\n    header: NoteHeader\n}\n\nglobal BET_NOTE_LEN: Field = 3;\n\nimpl BetNote {\n    pub fn new(_owner: AztecAddress, _bet: bool) -> Self {\n        BetNote {\n            owner: _owner,\n            randomness: rand(),\n            bet: _bet,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn serialize(self) -> [Field; BET_NOTE_LEN] {\n        [self.owner.address, self.randomness, self.bet as Field]\n    }\n\n    fn deserialize(preimage: [Field; BET_NOTE_LEN]) -> Self {\n        BetNote {\n            owner: AztecAddress::new(preimage[0]),\n            randomness: preimage[1],\n            bet: preimage[2] as bool,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_hash(self) -> Field {\n        dep::std::hash::pedersen_hash([\n            self.owner.address,\n            self.randomness,\n            self.bet as Field\n        ])\n    }\n\n    fn compute_nullifier(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_read_or_nullify(BetNoteMethods, self);\n        let nullifier_key = self.randomness;\n\n        dep::std::hash::pedersen_hash([\n            note_hash_for_nullify,\n            nullifier_key,\n        ])\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner.address);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            encryption_pub_key,\n            self.serialize(),\n        );\n    }\n}\n\nfn deserialize(preimage: [Field; BET_NOTE_LEN]) -> BetNote {\n    BetNote::deserialize(preimage)\n}\n\nfn serialize(note: BetNote) -> [Field; BET_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: BetNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: BetNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: BetNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut BetNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: BetNote) {\n    note.broadcast(context, slot);\n}\n\nglobal BetNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};",
        "path": "/Users/ngng/code/ng/aztec-coin-toss/src/types/bet_note.nr"
      },
      "88": {
        "source": "use dep::aztec::{\n    note::{\n        note_header::NoteHeader,\n        note_interface::NoteInterface,\n    },\n\n    context::PrivateContext,\n    types::{\n        address::AztecAddress\n    }\n};\n\nstruct ConfigNote {\n    divinity: AztecAddress,\n    private_oracle: AztecAddress,\n    house: AztecAddress,\n    bet_amount: Field,\n    header: NoteHeader\n}\n\nglobal CONFIG_NOTE_LEN: Field = 4;\n\nimpl ConfigNote {\n    pub fn new(_divinity: AztecAddress, _private_oracle: AztecAddress, _house: AztecAddress, _amount: Field) -> Self {\n        ConfigNote {\n            divinity: _divinity,\n            private_oracle: _private_oracle,\n            house: _house,\n            bet_amount: _amount,\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn serialize(self) -> [Field; CONFIG_NOTE_LEN] {\n        [self.divinity.address, self.private_oracle.address, self.house.address, self.bet_amount]\n    }\n\n    fn deserialize(preimage: [Field; CONFIG_NOTE_LEN]) -> Self {\n        ConfigNote {\n            divinity: AztecAddress::new(preimage[0]),\n            private_oracle: AztecAddress::new(preimage[1]),\n            house: AztecAddress::new(preimage[2]),\n            bet_amount: preimage[3],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_hash(self) -> Field {\n        dep::std::hash::pedersen_hash([\n            self.divinity.address,\n            self.private_oracle.address,\n            self.house.address,\n            self.bet_amount\n        ])\n    }\n\n    fn compute_nullifier(self) -> Field {\n         let _ = self; // Avoid compiler warning (same # acir opcodes and backend size)\n         0\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        // no owner == no broadcast\n        let _ = self; // Avoid compiler warning (same # acir opcodes and backend size)\n        let __ = context;\n        let ___ = slot;\n    }\n}\n\nfn deserialize(preimage: [Field; CONFIG_NOTE_LEN]) -> ConfigNote {\n    ConfigNote::deserialize(preimage)\n}\n\nfn serialize(note: ConfigNote) -> [Field; CONFIG_NOTE_LEN] {\n    note.serialize()\n}\n\nfn compute_note_hash(note: ConfigNote) -> Field {\n    note.compute_note_hash()\n}\n\nfn compute_nullifier(note: ConfigNote) -> Field {\n    note.compute_nullifier()\n}\n\nfn get_header(note: ConfigNote) -> NoteHeader {\n    note.header\n}\n\nfn set_header(note: &mut ConfigNote, header: NoteHeader) {\n    note.set_header(header)\n}\n\nfn broadcast(context: &mut PrivateContext, slot: Field, note: ConfigNote) {\n    note.broadcast(context, slot);\n}\n\nglobal ConfigNoteMethods = NoteInterface {\n    deserialize,\n    serialize,\n    compute_note_hash,\n    compute_nullifier,\n    get_header,\n    set_header,\n    broadcast,\n};",
        "path": "/Users/ngng/code/ng/aztec-coin-toss/src/types/config_note.nr"
      }
    }
  }
}